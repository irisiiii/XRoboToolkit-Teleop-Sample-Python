#include "frame_sync/msg/synced_data.hpp"
#include <message_filters/subscriber.h>
#include <message_filters/sync_policies/approximate_time.h>
#include <message_filters/synchronizer.h>
#include <message_filters/time_synchronizer.h>
#include <rclcpp/rclcpp.hpp>
#include <sensor_msgs/msg/image.hpp>
#include <sensor_msgs/msg/joint_state.hpp>
#include <mutex>
#include <memory>
#include <chrono>
class FrameSyncNode : public rclcpp::Node {
public:
  FrameSyncNode() : Node("frame_sync_node") {
    RCLCPP_INFO(this->get_logger(), "Frame Sync Node has started.");
    
    // 声明参数
    this->declare_parameter("output_frequency", 20.0); // 默认20Hz
    this->declare_parameter("force_frequency", false); // 是否强制频率发布
    double output_freq = this->get_parameter("output_frequency").as_double();
    force_frequency_ = this->get_parameter("force_frequency").as_bool();
    
    // 初始化相机订阅者数组
    std::vector<std::string> camera_topics = {"/left_camera/color/image_raw",
                                              "/right_camera/color/image_raw",
                                              "/top_camera/color/image_raw"};
    for (const auto &topic : camera_topics) {
      image_subs_.emplace_back(
          std::make_shared<
              message_filters::Subscriber<sensor_msgs::msg::Image>>(this,
                                                                    topic));
    }
    // 初始化机械臂订阅者数组
    std::vector<std::string> arm_topics = {"/left_arm/joint_states",
                                           "/right_arm/joint_states"};
    for (const auto &topic : arm_topics) {
      arm_subs_.emplace_back(
          std::make_shared<
              message_filters::Subscriber<sensor_msgs::msg::JointState>>(
              this, topic));
    }
    SyncedData_pub_ =
        this->create_publisher<frame_sync::msg::SyncedData>("/syncedData", 10);

    // 使用ApproximateTime策略
    typedef message_filters::sync_policies::ApproximateTime<
        sensor_msgs::msg::Image, sensor_msgs::msg::Image,
        sensor_msgs::msg::Image, sensor_msgs::msg::JointState,
        sensor_msgs::msg::JointState>
        ApproxSyncPolicy;

    sync_ = std::make_shared<message_filters::Synchronizer<ApproxSyncPolicy>>(
        ApproxSyncPolicy(10), *image_subs_[0], *image_subs_[1], *image_subs_[2],
        *arm_subs_[0], *arm_subs_[1]);

    sync_->registerCallback(
        std::bind(&FrameSyncNode::syncCallback, this, std::placeholders::_1,
                  std::placeholders::_2, std::placeholders::_3,
                  std::placeholders::_4, std::placeholders::_5));

    // 创建定时器控制发布频率
    auto timer_period = std::chrono::duration<double>(1.0 / output_freq);
    publish_timer_ = this->create_wall_timer(
        timer_period, std::bind(&FrameSyncNode::publishTimerCallback, this));

    RCLCPP_INFO(this->get_logger(), "Arm and camera sync node initialized with %.1f Hz output", output_freq);
  }
  ~FrameSyncNode() {
    RCLCPP_INFO(this->get_logger(), "Frame Sync Node is shutting down.");
    // Cleanup code here
  }

private:
  void
  syncCallback(const sensor_msgs::msg::Image::ConstSharedPtr &image1,
           const sensor_msgs::msg::Image::ConstSharedPtr &image2,
           const sensor_msgs::msg::Image::ConstSharedPtr &image3,
           const sensor_msgs::msg::JointState::ConstSharedPtr &arm1_state,
           const sensor_msgs::msg::JointState::ConstSharedPtr &arm2_state) {
    
    // 使用互斥锁保护共享数据
    std::lock_guard<std::mutex> lock(data_mutex_);
    
    // 打印时间戳以验证同步
    double time1 =
        image1->header.stamp.sec + image1->header.stamp.nanosec * 1e-9;
    double time2 =
        image2->header.stamp.sec + image2->header.stamp.nanosec * 1e-9;
    double time3 =
        image3->header.stamp.sec + image3->header.stamp.nanosec * 1e-9;
    double time_arm1 =
        arm1_state->header.stamp.sec + arm1_state->header.stamp.nanosec * 1e-9;
    double time_arm2 =
        arm2_state->header.stamp.sec + arm2_state->header.stamp.nanosec * 1e-9;
    double avg_time = (time1 + time2 + time3 + time_arm1 + time_arm2) / 5.0;
    
    RCLCPP_DEBUG(this->get_logger(),
                "Synchronized data at time: Image1 %f, Image2 %f, Image3 %f, "
                "Arm1 %f, Arm2 %f",
                time1, time2, time3, time_arm1, time_arm2);

    // 缓存最新的同步数据
    latest_synced_data_ = std::make_unique<frame_sync::msg::SyncedData>();
    latest_synced_data_->left_image = *image1;
    latest_synced_data_->right_image = *image2;
    latest_synced_data_->top_image = *image3;
    latest_synced_data_->left_joint_states = *arm1_state;
    latest_synced_data_->right_joint_states = *arm2_state;
    
    // Convert back to sec and nanosec
    int32_t sec = static_cast<int32_t>(std::floor(avg_time));
    uint32_t nanosec = static_cast<uint32_t>((avg_time - sec) * 1e9);

    // Set the header timestamp
    latest_synced_data_->header.stamp.sec = sec;
    latest_synced_data_->header.stamp.nanosec = nanosec;
    latest_synced_data_->header.frame_id = "synced_data";
    
    has_new_data_ = true;
  }

  void publishTimerCallback() {
    std::lock_guard<std::mutex> lock(data_mutex_);
    
    if (has_new_data_ && latest_synced_data_) {
      // 创建副本用于发布
      auto msg_to_publish = std::make_unique<frame_sync::msg::SyncedData>(*latest_synced_data_);
      SyncedData_pub_->publish(std::move(msg_to_publish));
      has_new_data_ = false;
      
      RCLCPP_DEBUG(this->get_logger(), "Published synced data at controlled frequency");
    } else if (force_frequency_ && latest_synced_data_) {
      // 强制频率模式：重复发布最后一帧
      auto msg_to_publish = std::make_unique<frame_sync::msg::SyncedData>(*latest_synced_data_);
      // 更新时间戳为当前时间
      auto now = this->get_clock()->now();
      msg_to_publish->header.stamp = now;
      SyncedData_pub_->publish(std::move(msg_to_publish));
      
      RCLCPP_DEBUG(this->get_logger(), "Force published last synced data to maintain frequency");
    } else {
      // 记录没有新数据的情况，帮助诊断瓶颈
      RCLCPP_WARN_THROTTLE(this->get_logger(), *this->get_clock(), 1000,
                           "Timer triggered but no new synced data available - upstream bottleneck detected");
    }
  }
  std::vector<
      std::shared_ptr<message_filters::Subscriber<sensor_msgs::msg::Image>>>
      image_subs_;
  std::vector<std::shared_ptr<
      message_filters::Subscriber<sensor_msgs::msg::JointState>>>
      arm_subs_;
  std::shared_ptr<message_filters::Synchronizer<
      message_filters::sync_policies::ApproximateTime<
          sensor_msgs::msg::Image, sensor_msgs::msg::Image,
          sensor_msgs::msg::Image, sensor_msgs::msg::JointState,
          sensor_msgs::msg::JointState>>>
      sync_;
  std::vector<rclcpp::Subscription<sensor_msgs::msg::Image>::SharedPtr>
      debug_image_subs_;
  std::vector<rclcpp::Subscription<sensor_msgs::msg::JointState>::SharedPtr>
      debug_arm_subs_;
  rclcpp::Publisher<frame_sync::msg::SyncedData>::SharedPtr SyncedData_pub_;
  
  // 新增成员变量用于频率控制
  rclcpp::TimerBase::SharedPtr publish_timer_;
  std::mutex data_mutex_;
  std::unique_ptr<frame_sync::msg::SyncedData> latest_synced_data_;
  bool has_new_data_ = false;
  bool force_frequency_ = false;
};

int main() {
  rclcpp::init(0, nullptr);
  auto node = std::make_shared<FrameSyncNode>();
  RCLCPP_INFO(node->get_logger(), "Frame Sync Node has started.");
  rclcpp::spin(node);
  rclcpp::shutdown();
  return 0;
}